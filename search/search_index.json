{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kubernetes RBAC can sometimes appear to be some sort of black magic. So, let's look behind the curtain. Snippets \u00b6 We all love YAML, right? Here's a collection of annotated RBAC-related YAML snippets you can build on. Reuse roles \u00b6 To re-use a role across namespaces, first define a cluster role, for example, to view services , using: 1 2 3 4 5 6 7 8 9 10 11 12 apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : name : perm-svc-view rules : - apiGroups : - \"\" resources : - services verbs : - get - list Assign above cluster role to user greta , allowing her to view services in the namespace dev123 using: 1 2 3 4 5 6 7 8 9 10 11 12 13 apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : assign-perm-greta-svc-view namespace : dev123 roleRef : apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : perm-svc-view subjects : - apiGroup : rbac.authorization.k8s.io kind : User name : greta Tip To validate if the permissions have been granted, have a look at checking for permissions . Aggregate roles \u00b6 Cluster roles can be created by combining other cluster roles using aggregationRule . The Kubernetes controller manager will take care of filling the rules based on the labels defined in the template. To test it out, create the below rule in a file called namespace-admin.yaml : 1 2 3 4 5 6 7 8 9 apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : name : namespace-admin aggregationRule : clusterRoleSelectors : - matchLabels : rbac.example.com/aggregate-to-namespace-admin : \"true\" rules : [] # rules are automatically filled in by controller manager And create the cluster role: 1 2 3 kubectl apply -f namespace-admin.yaml clusterrole.rbac.authorization.k8s.io/namespace-admin created If you look at the rules section in the below output, you can see that it has no rules: 1 2 3 4 5 6 7 $ kubectl describe clusterrole namespace-admin Name: namespace-admin Labels: <none> Annotations: <none> PolicyRule: Resources Non-Resource URLs Resource Names Verbs --------- ----------------- -------------- ----- Let us create another cluster role with the label rbac.example.com/aggregate-to-namespace-admin : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : annotations : rbac.authorization.kubernetes.io/autoupdate : \"true\" labels : rbac.example.com/aggregate-to-namespace-admin : \"true\" name : aggregate-to-namespace-admin rules : - apiGroups : - apps resources : - deployments verbs : - create - delete - patch - update And create it: 1 2 3 kubectl apply -f aggregate-to-namespace-admin.yaml clusterrole.rbac.authorization.k8s.io/aggregate-to-namespace-admin created Now check the permissions for the namespace-admin role. You can see that the controller manager aggregated all the rules based on the labels. 1 2 3 4 5 6 7 8 kubectl describe clusterrole namespace-admin Name: namespace-admin Labels: <none> Annotations: <none> PolicyRule: Resources Non-Resource URLs Resource Names Verbs --------- ----------------- -------------- ----- deployments.apps [] [] [ create delete patch update ] Give namespace admin \u00b6 Allow developer to deploy \u00b6 Commands \u00b6 Some kubectl commands that might come in handy. Creating roles \u00b6 To create a cluster role: 1 2 3 kubectl create clusterrole perm-view-deploys \\ --verb = get --verb = list \\ --resource = deployments To create a role in namespace somens : 1 2 3 4 kubectl create role perm-view-deploys-in-somens \\ --verb = get,list,watch \\ --resource = deployments \\ --namespace = somens Creating role bindings \u00b6 To create a cluster role binding, that is, assign a cluster role to user: 1 2 3 kubectl create clusterrolebinding assign-perm-view-deploys \\ --clusterrole = perm-view-deploys \\ --user = greta To create a role binding, that is, assign role to user in namespace somens : 1 2 3 4 kubectl create rolebinding assign-perm-view-deploys-in-somens \\ --role = perm-view-deploys-in-somens \\ --user = greta \\ --namespace = somens Tip If you just want to see what the YAML manifest would look like that the kuebctl command creates, that is, no create the resource, append -o yaml --dry-run to the respective command. Checking for permissions \u00b6 Can the user greta list services in the namespace dev123 ? 1 2 3 4 $ kubectl auth can-i \\ list services \\ --as = greta \\ --namespace = dev123 Can the service account dummy create services in the namespace danger ? 1 2 3 4 $ kubectl auth can-i \\ create services \\ --as = system:serviceaccount:danger:dummy \\ --namespace = danger","title":"Base"},{"location":"#snippets","text":"We all love YAML, right? Here's a collection of annotated RBAC-related YAML snippets you can build on.","title":"Snippets"},{"location":"#reuse-roles","text":"To re-use a role across namespaces, first define a cluster role, for example, to view services , using: 1 2 3 4 5 6 7 8 9 10 11 12 apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : name : perm-svc-view rules : - apiGroups : - \"\" resources : - services verbs : - get - list Assign above cluster role to user greta , allowing her to view services in the namespace dev123 using: 1 2 3 4 5 6 7 8 9 10 11 12 13 apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : assign-perm-greta-svc-view namespace : dev123 roleRef : apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : perm-svc-view subjects : - apiGroup : rbac.authorization.k8s.io kind : User name : greta Tip To validate if the permissions have been granted, have a look at checking for permissions .","title":"Reuse roles"},{"location":"#aggregate-roles","text":"Cluster roles can be created by combining other cluster roles using aggregationRule . The Kubernetes controller manager will take care of filling the rules based on the labels defined in the template. To test it out, create the below rule in a file called namespace-admin.yaml : 1 2 3 4 5 6 7 8 9 apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : name : namespace-admin aggregationRule : clusterRoleSelectors : - matchLabels : rbac.example.com/aggregate-to-namespace-admin : \"true\" rules : [] # rules are automatically filled in by controller manager And create the cluster role: 1 2 3 kubectl apply -f namespace-admin.yaml clusterrole.rbac.authorization.k8s.io/namespace-admin created If you look at the rules section in the below output, you can see that it has no rules: 1 2 3 4 5 6 7 $ kubectl describe clusterrole namespace-admin Name: namespace-admin Labels: <none> Annotations: <none> PolicyRule: Resources Non-Resource URLs Resource Names Verbs --------- ----------------- -------------- ----- Let us create another cluster role with the label rbac.example.com/aggregate-to-namespace-admin : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : annotations : rbac.authorization.kubernetes.io/autoupdate : \"true\" labels : rbac.example.com/aggregate-to-namespace-admin : \"true\" name : aggregate-to-namespace-admin rules : - apiGroups : - apps resources : - deployments verbs : - create - delete - patch - update And create it: 1 2 3 kubectl apply -f aggregate-to-namespace-admin.yaml clusterrole.rbac.authorization.k8s.io/aggregate-to-namespace-admin created Now check the permissions for the namespace-admin role. You can see that the controller manager aggregated all the rules based on the labels. 1 2 3 4 5 6 7 8 kubectl describe clusterrole namespace-admin Name: namespace-admin Labels: <none> Annotations: <none> PolicyRule: Resources Non-Resource URLs Resource Names Verbs --------- ----------------- -------------- ----- deployments.apps [] [] [ create delete patch update ]","title":"Aggregate roles"},{"location":"#give-namespace-admin","text":"","title":"Give namespace admin"},{"location":"#allow-developer-to-deploy","text":"","title":"Allow developer to deploy"},{"location":"#commands","text":"Some kubectl commands that might come in handy.","title":"Commands"},{"location":"#creating-roles","text":"To create a cluster role: 1 2 3 kubectl create clusterrole perm-view-deploys \\ --verb = get --verb = list \\ --resource = deployments To create a role in namespace somens : 1 2 3 4 kubectl create role perm-view-deploys-in-somens \\ --verb = get,list,watch \\ --resource = deployments \\ --namespace = somens","title":"Creating roles"},{"location":"#creating-role-bindings","text":"To create a cluster role binding, that is, assign a cluster role to user: 1 2 3 kubectl create clusterrolebinding assign-perm-view-deploys \\ --clusterrole = perm-view-deploys \\ --user = greta To create a role binding, that is, assign role to user in namespace somens : 1 2 3 4 kubectl create rolebinding assign-perm-view-deploys-in-somens \\ --role = perm-view-deploys-in-somens \\ --user = greta \\ --namespace = somens Tip If you just want to see what the YAML manifest would look like that the kuebctl command creates, that is, no create the resource, append -o yaml --dry-run to the respective command.","title":"Creating role bindings"},{"location":"#checking-for-permissions","text":"Can the user greta list services in the namespace dev123 ? 1 2 3 4 $ kubectl auth can-i \\ list services \\ --as = greta \\ --namespace = dev123 Can the service account dummy create services in the namespace danger ? 1 2 3 4 $ kubectl auth can-i \\ create services \\ --as = system:serviceaccount:danger:dummy \\ --namespace = danger","title":"Checking for permissions"},{"location":"apps/","text":"Sometimes it's hard to figure out what exactly the least privileges for a certain app are and we resort to giving cluster-admin permissions for apps running in our Kubernetes cluster. This is great news for attackers, but not so great news for the fine folks who are on-call for the cluster. The good practice is to use tools such as audit2rbac to right-size the permissions. In the following, we have a look at sensible RBAC settings for common apps. Prometheus \u00b6 Elasticsearch \u00b6 MySQL \u00b6 Kafka \u00b6 Istio \u00b6 Kubeflow \u00b6","title":"Applications"},{"location":"apps/#prometheus","text":"","title":"Prometheus"},{"location":"apps/#elasticsearch","text":"","title":"Elasticsearch"},{"location":"apps/#mysql","text":"","title":"MySQL"},{"location":"apps/#kafka","text":"","title":"Kafka"},{"location":"apps/#istio","text":"","title":"Istio"},{"location":"apps/#kubeflow","text":"","title":"Kubeflow"},{"location":"contribs/","text":"This site was initiated by Michael Hausenblas and received contributions from: Sathish If you have an RBAC recipe you'd like to share, please PR mhausenblas/rbacadabra . Also, if you have a suggestion for a recipe, something that is missing, please create an issue, there.","title":"Contributors"},{"location":"vis/","text":"The RBAC permissions form a graph: users and service accounts as the entities (or: actors) who want to carry out certain tasks, (cluster) roles stating the allowed actions (think: policies), and (cluster) role bindings that assign (cluster) roles to entities, effectively permitting them to do certain things to certain resources. Since there are many moving parts and connections between them, visualizing them is a good way to get an overview what is going on in the cluster from a permissions point-of-view and also to understand who's allowed to do what. Graph \u00b6 Info The following example assumes you're using macOS. If you have rback and Graphviz installed, you can generate a permissions graph like so: 1 2 3 4 5 kubectl get sa,roles,rolebindings,clusterroles,clusterrolebindings \\ --all-namespaces -o json | \\ rback | \\ dot -Tpng > /tmp/rback.png && \\ open /tmp/rback.png Resulting in something like the following permissions graph (and note that only a small part is shown here): Matrix \u00b6 Available as krew plugins : 1 2 3 kubectl access-matrix --as greta -n somens kubectl rbac-view","title":"Visualizations"},{"location":"vis/#graph","text":"Info The following example assumes you're using macOS. If you have rback and Graphviz installed, you can generate a permissions graph like so: 1 2 3 4 5 kubectl get sa,roles,rolebindings,clusterroles,clusterrolebindings \\ --all-namespaces -o json | \\ rback | \\ dot -Tpng > /tmp/rback.png && \\ open /tmp/rback.png Resulting in something like the following permissions graph (and note that only a small part is shown here):","title":"Graph"},{"location":"vis/#matrix","text":"Available as krew plugins : 1 2 3 kubectl access-matrix --as greta -n somens kubectl rbac-view","title":"Matrix"}]}